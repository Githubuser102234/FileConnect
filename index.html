<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Vault</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for aesthetic appeal and responsiveness */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            min-height: 100vh;
        }
        .media-container {
            position: relative;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            overflow: hidden;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            background-color: #1f2937; /* Dark background for media */
        }
        .media-item {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }
        .media-container:hover .media-item {
            transform: scale(1.03);
        }
        /* Custom scrollbar for better look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        ::-webkit-scrollbar-thumb {
            background: #a1a1aa;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #71717a;
        }

        /* --- NEW: Full View Mode Styles --- */
        .full-view-mode #app {
            display: none; /* Hide the entire application UI */
        }
        .full-view-mode {
            background-color: #000; /* Dark background for media viewing */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* Hide scrollbars in full view */
        }
        .full-view-mode iframe {
            display: block;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <!-- Main Application Container (Hidden in full-view mode) -->
    <div id="app" class="max-w-7xl mx-auto">
        
        <!-- Header: Simplified Title -->
        <header class="text-center mb-10 py-4 bg-white rounded-xl shadow-lg">
            <h1 class="text-4xl font-extrabold text-indigo-700">Media Vault</h1>
        </header>

        <!-- Upload Section -->
        <section id="upload-section" class="bg-white p-6 rounded-xl shadow-lg mb-10">
            
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-2xl font-semibold text-gray-800">Upload New File</h2>
                <span class="inline-flex items-center px-3 py-1 text-sm font-medium bg-green-100 text-green-800 rounded-full">
                    Supported types: All
                </span>
            </div>
            
            <div id="message-box" class="hidden p-3 mb-4 text-sm rounded-lg" role="alert"></div>

            <!-- Input accepts all file types -->
            <input type="file" id="media-file-input" class="w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-full file:border-0
                file:text-sm file:font-semibold
                file:bg-indigo-50 file:text-indigo-700
                hover:file:bg-indigo-100" />
            
            <div class="mt-4">
                <input type="text" id="media-title-input" placeholder="Title (e.g., Project Document or My Video)"
                       class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
            </div>

            <button id="upload-btn" class="mt-4 w-full px-6 py-3 bg-indigo-600 text-white font-bold rounded-xl hover:bg-indigo-700 transition duration-150 shadow-md disabled:opacity-50" disabled>
                <span id="upload-text">Upload File</span>
                <span id="upload-spinner" class="hidden animate-spin h-5 w-5 border-4 border-white border-t-transparent rounded-full ml-2"></span>
            </button>
            
            <!-- Upload Status Display -->
            <div id="upload-status" class="text-sm text-center mt-2 font-medium text-indigo-500 invisible">Ready to upload.</div>
            
        </section>

        <!-- Gallery Section -->
        <section id="gallery-section">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">Shared Media Gallery</h2>
            <div id="media-gallery" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                <div id="loading-gallery" class="col-span-full text-center text-gray-500 p-10">
                    Loading media...
                </div>
                <!-- Media items will be injected here -->
            </div>
        </section>

        <!-- Modal for displaying full media or error messages -->
        <div id="media-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center p-4 z-50 transition-opacity duration-300">
            <div class="bg-white rounded-xl max-w-4xl w-full p-4 relative">
                <button onclick="document.getElementById('media-modal').classList.add('hidden')" class="absolute top-2 right-2 text-gray-700 hover:text-gray-900 text-3xl font-bold p-1 leading-none rounded-full bg-gray-200 w-10 h-10 flex items-center justify-center">
                    &times;
                </button>
                <div id="modal-content">
                    <!-- Media element or error message will be placed here -->
                </div>
            </div>
        </div>

    </div>

    <!-- Firebase and Application Logic -->
    <script type="module">
        // 1. HARDCODED CONFIGURATION AND IMPORTS (Based on User Request)
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyBxNgcLIk4KLxzqVsgA7tLHHM7Rpf1PWvY",
            authDomain: "fileconnect-fd3e3.firebaseapp.com",
            projectId: "fileconnect-fd3e3",
            storageBucket: "fileconnect-fd3e3.firebasestorage.app",
            messagingSenderId: "900879046037",
            appId: "1:900879046037:web:8560c5b3b57be8740d929c",
            measurementId: "G-B7RR873MSB"
        };
        const FIXED_APP_ID = FIREBASE_CONFIG.projectId;

        // Load specific SDK versions provided by the user
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, onSnapshot, collection, query, orderBy, serverTimestamp, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore.js";

        // Global Firebase instances
        let app, db, auth;
        let userId = null;
        let isAuthReady = false;

        // CONSTANTS
        const CHUNK_SIZE = 900000; 
        const MEDIA_COLLECTION_PATH = `artifacts/${FIXED_APP_ID}/public/data/media_files`;

        const messageBox = document.getElementById('message-box');
        const uploadBtn = document.getElementById('upload-btn');
        const uploadSpinner = document.getElementById('upload-spinner');
        const mediaFileInput = document.getElementById('media-file-input');
        const mediaTitleInput = document.getElementById('media-title-input');
        const mediaGallery = document.getElementById('media-gallery');
        const modal = document.getElementById('media-modal');
        const modalContent = document.getElementById('modal-content');
        const uploadStatus = document.getElementById('upload-status'); 

        /**
         * Initializes Firebase and authenticates the user anonymously.
         */
        async function initFirebase() {
            try {
                // Initialize app and services
                app = initializeApp(FIREBASE_CONFIG);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // Start anonymous sign-in process
                await signInAnonymously(auth);

                // Authentication listener to get user ID
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        uploadBtn.disabled = false;
                        uploadStatus.classList.remove('invisible');
                        startGalleryListener(); 
                        handleUrlParameters(); // Check URL for parameters after auth
                    } else {
                        console.error("Authentication failed: User object is null.");
                        uploadBtn.disabled = true;
                    }
                });

            } catch (error) {
                console.error("Firebase Initialization/Authentication Error:", error);
                showSystemMessage(`Authentication failed: ${error.message}`, 'bg-red-100 text-red-800');
            }
        }

        /**
         * Converts a File object to a Base64 data URL string.
         */
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = (error) => reject(error);
            });
        }

        /**
         * Splits a Base64 string into chunks of a specified size.
         */
        function chunkBase64(base64DataUrl) {
            const commaIndex = base64DataUrl.indexOf(',');
            if (commaIndex === -1) {
                throw new Error("Invalid Base64 Data URL format.");
            }
            const base64String = base64DataUrl.substring(commaIndex + 1);
            
            const chunks = [];
            for (let i = 0; i < base64String.length; i += CHUNK_SIZE) {
                chunks.push(base64String.substring(i, i + CHUNK_SIZE));
            }
            return chunks;
        }

        /**
         * Uploads the file in chunks to Firestore, updating the progress status.
         */
        async function handleUpload() {
            const file = mediaFileInput.files[0];
            const title = mediaTitleInput.value.trim();

            if (!file || !title) {
                showSystemMessage("Please select a file and enter a title.", 'bg-yellow-100 text-yellow-800');
                return;
            }

            setLoading(true, "Encoding & Chunking...");
            uploadStatus.textContent = "Processing file...";

            let base64DataUrl, chunks;
            try {
                base64DataUrl = await fileToBase64(file);
                chunks = chunkBase64(base64DataUrl);
            } catch (error) {
                setLoading(false);
                uploadStatus.textContent = "Ready to upload.";
                showSystemMessage(`File processing failed: ${error.message}`, 'bg-red-100 text-red-800');
                return;
            }
            
            setLoading(true, `Starting upload...`);

            try {
                // 1. Create the root document for metadata
                const newDocRef = await addDoc(collection(db, MEDIA_COLLECTION_PATH), {
                    title: title,
                    mimeType: file.type,
                    chunkCount: chunks.length,
                    fileSize: file.size, 
                    uploadedBy: userId,
                    timestamp: serverTimestamp()
                });

                // 2. Upload the chunks to a subcollection
                const chunkCollectionRef = collection(db, MEDIA_COLLECTION_PATH, newDocRef.id, 'chunks');
                
                // Get the MIME type header (e.g., data:image/jpeg;base64,)
                const mimeTypeHeader = base64DataUrl.substring(0, base64DataUrl.indexOf(',') + 1);

                // Store the header in the main document
                await setDoc(newDocRef, { mimeTypeHeader: mimeTypeHeader }, { merge: true });

                let uploadedCount = 0;
                const chunkUploadPromises = [];

                // Function to update status
                const updateStatus = () => {
                    uploadedCount++;
                    const statusText = `[${uploadedCount}/${chunks.length} chunk(s)]`;
                    uploadStatus.textContent = statusText;
                    // Use setTimeout to allow the main thread to update the UI
                    setTimeout(() => { setLoading(true, `Uploading chunk ${uploadedCount} of ${chunks.length}...`); }, 0);
                };

                for (let i = 0; i < chunks.length; i++) {
                    const chunkDocRef = doc(chunkCollectionRef, i.toString());
                    
                    // Wrap the setDoc promise to update the status upon resolution
                    const uploadPromise = setDoc(chunkDocRef, {
                        index: i,
                        data: chunks[i],
                        timestamp: serverTimestamp()
                    }).then(() => {
                        updateStatus();
                    });
                    chunkUploadPromises.push(uploadPromise);
                }
                
                await Promise.all(chunkUploadPromises);

                showSystemMessage(`Successfully uploaded "${title}" in ${chunks.length} chunks!`, 'bg-green-100 text-green-800');
                mediaFileInput.value = '';
                mediaTitleInput.value = '';

            } catch (error) {
                console.error("Firestore Upload Error:", error);
                showSystemMessage(`Upload failed: ${error.message}`, 'bg-red-100 text-red-800');
            } finally {
                setLoading(false);
                uploadStatus.textContent = "Upload complete. Ready for next file.";
                setTimeout(() => { uploadStatus.textContent = "Ready to upload."; }, 5000);
            }
        }
        
        /**
         * Fetches metadata for a single media item.
         */
        async function getMediaMetadata(mediaId) {
            const docRef = doc(db, MEDIA_COLLECTION_PATH, mediaId);
            const docSnap = await getDoc(docRef);
            
            if (!docSnap.exists()) {
                throw new Error(`File ID ${mediaId} not found.`);
            }
            const data = docSnap.data();
            if (!data.mimeTypeHeader || data.chunkCount === undefined) {
                 throw new Error("Shared file metadata is incomplete.");
            }
            return { id: docSnap.id, ...data };
        }


        /**
         * Retrieves all chunks for a given media ID and reassembles the Base64 data URL.
         */
        async function getAndReassembleMedia(mediaId, mimeTypeHeader, chunkCount) {
            const chunkCollectionRef = collection(db, MEDIA_COLLECTION_PATH, mediaId, 'chunks');
            
            // Note: Since we are loading all data, performance might be slow for many files/large chunks. 
            // We fetch and sort in memory, avoiding orderBy which can lead to index issues.
            const chunkQuerySnapshot = await getDocs(chunkCollectionRef); 

            if (chunkQuerySnapshot.docs.length !== chunkCount) {
                 throw new Error(`Mismatched chunk count (${chunkQuerySnapshot.docs.length} found, ${chunkCount} expected).`);
            }

            const chunkArray = Array(chunkCount);

            chunkQuerySnapshot.forEach(docSnapshot => {
                const chunkData = docSnapshot.data();
                if (typeof chunkData.index === 'number' && chunkData.data) {
                    chunkArray[chunkData.index] = chunkData.data;
                }
            });
            
            // Sort the array based on index (even though Firestore IDs are retrieved, we ensure order)
            // Note: The index is stored as a field in the doc, but we must rely on the array position
            // after iterating, so we must ensure all indices were present.
            if (chunkArray.some(chunk => chunk === undefined)) {
                 throw new Error("Missing chunks detected during reassembly.");
            }

            const fullBase64String = chunkArray.join('');
            
            if (!fullBase64String) {
                throw new Error("Reassembled Base64 string is empty.");
            }

            return `${mimeTypeHeader}${fullBase64String}`;
        }

        /**
         * Renders the minimal, UI-less full view content.
         */
        async function renderFullView(mediaId) {
            document.body.classList.add('full-view-mode');
            
            // Minimal error display for full view
            const displayError = (message) => {
                document.body.innerHTML = `
                    <div class="text-white p-8 bg-red-800 rounded-lg max-w-lg text-center mx-auto absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
                        <h1 class="text-3xl font-bold mb-4">Content Load Error</h1>
                        <p>${message}</p>
                        <a href="${window.location.origin + window.location.pathname}" class="mt-4 inline-block text-blue-300 hover:text-blue-100 text-sm underline">Go back to Vault</a>
                    </div>`;
            };

            try {
                const item = await getMediaMetadata(mediaId);
                
                // Show a loading spinner in the full view
                document.body.innerHTML = `
                    <div class="text-white text-center">
                        <div class="animate-spin h-10 w-10 border-4 border-indigo-500 border-t-transparent rounded-full mx-auto"></div>
                        <p class="mt-4 text-lg">Loading: ${item.title}...</p>
                    </div>`;

                const dataUrl = await getAndReassembleMedia(item.id, item.mimeTypeHeader, item.chunkCount);
                const mimeType = item.mimeType;

                let mediaElement = '';
                
                if (mimeType.startsWith('image/')) {
                    mediaElement = `<img src="${dataUrl}" alt="${item.title}" class="block max-h-screen max-w-screen object-contain mx-auto">`;
                } else if (mimeType.startsWith('video/')) {
                    mediaElement = `<video src="${dataUrl}" controls autoplay loop class="block max-h-screen max-w-screen mx-auto"></video>`;
                } else if (mimeType.startsWith('audio/')) {
                    // Minimal audio player centered in a dark box
                    mediaElement = `<div class="p-8 bg-gray-900 rounded-xl shadow-2xl">
                                        <p class="text-white text-lg mb-4 font-semibold">${item.title} (Audio)</p>
                                        <audio src="${dataUrl}" controls autoplay class="w-full"></audio>
                                    </div>`;
                } else if (mimeType === 'application/pdf' || mimeType.startsWith('text/') || mimeType === 'application/json' || mimeType === 'application/xml') {
                    // Use iframe for documents/code. Requires full screen size.
                    document.body.style.backgroundColor = 'white'; 
                    document.body.style.display = 'block'; // Allow iframe to take up full body space
                    mediaElement = `<iframe src="${dataUrl}" class="w-full h-screen border-0"></iframe>`;
                } else {
                     // Non-previewable types
                     displayError(`File Type Warning: This file type (${mimeType}) cannot be directly displayed in this minimalist view.`);
                     return;
                }

                document.body.innerHTML = mediaElement;
                
            } catch (error) {
                console.error("Full View Error:", error);
                displayError(`Failed to load content. Data may be incomplete or corrupted.`);
            }
        }


        /**
         * Starts the real-time listener for the media gallery.
         */
        function startGalleryListener() {
            if (!isAuthReady || !db) return;

            const mediaQuery = query(collection(db, MEDIA_COLLECTION_PATH), orderBy('timestamp', 'desc'));

            onSnapshot(mediaQuery, (snapshot) => {
                const mediaItems = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.title && data.mimeType && data.chunkCount !== undefined && data.mimeTypeHeader) {
                         mediaItems.push({ id: doc.id, ...data });
                    }
                });
                renderGallery(mediaItems);
            }, (error) => {
                console.error("Gallery Snapshot Error:", error);
                document.getElementById('loading-gallery').textContent = `Failed to load gallery: ${error.message}`;
            });
        }

        /**
         * Renders the media gallery based on the fetched metadata.
         */
        function renderGallery(items) {
            mediaGallery.innerHTML = ''; // Clear existing content

            if (items.length === 0) {
                mediaGallery.innerHTML = `<p class="col-span-full text-center text-gray-500 p-10">No media uploaded yet. Be the first!</p>`;
                return;
            }

            items.forEach(item => {
                const mime = item.mimeType.split('/')[0];
                const mediaType = mime === 'video' || mime === 'image' || mime === 'audio' ? mime.toUpperCase() : 'FILE';
                const fileSizeMB = (item.fileSize / (1024 * 1024)).toFixed(2);
                const placeholderText = `${mediaType} (${fileSizeMB} MB)`;

                const card = document.createElement('div');
                card.className = 'bg-white rounded-xl shadow-md overflow-hidden transition transform hover:shadow-xl hover:-translate-y-1 cursor-pointer';
                card.onclick = () => window.showMediaModal(item);

                const previewHtml = `<div class="media-container"><img src="https://placehold.co/600x337/3B82F6/ffffff?text=${encodeURIComponent(placeholderText)}%0A(Click%20to%20Load)" class="media-item object-cover w-full h-full" alt="Media Preview"/></div>`;

                card.innerHTML = `
                    ${previewHtml}
                    <div class="p-4">
                        <h3 class="text-lg font-semibold text-gray-800 truncate">${item.title}</h3>
                        <p class="text-sm text-gray-500 mt-1">
                            ${item.mimeType} | 
                            ${item.chunkCount} chunks
                        </p>
                        <p class="text-xs text-gray-400 mt-1">Uploaded by: ${item.uploadedBy.substring(0, 8)}...</p>
                        <div class="flex justify-between items-center mt-2">
                            <button onclick="event.stopPropagation(); window.deleteMedia('${item.id}', '${item.title}', ${item.chunkCount})" 
                                    class="text-xs text-red-500 hover:text-red-700 transition duration-150 font-medium">
                                Delete
                            </button>
                            <!-- Share Link Button -->
                            <button onclick="event.stopPropagation(); window.copyShareLink('${item.id}', true)" 
                                    class="text-xs text-indigo-600 hover:text-indigo-800 transition duration-150 font-medium p-1 rounded-md bg-indigo-50">
                                Copy Share Link
                            </button>
                            <!-- Full View Link Button -->
                            <button onclick="event.stopPropagation(); window.copyShareLink('${item.id}', false)" 
                                    class="text-xs text-purple-600 hover:text-purple-800 transition duration-150 font-medium p-1 rounded-md bg-purple-50">
                                Copy Full View Link
                            </button>
                        </div>
                    </div>
                `;
                mediaGallery.appendChild(card);
            });
        }

        /**
         * Utility to copy a string to the clipboard.
         * @param {string} mediaId - The ID of the media item.
         * @param {boolean} isShare - True for ?share=, false for ?fullview=.
         */
        window.copyShareLink = (mediaId, isShare) => {
            const param = isShare ? 'share' : 'fullview';
            const linkText = isShare ? 'Share link' : 'Full View link';
            
            const shareUrl = window.location.origin + window.location.pathname + `?${param}=${mediaId}`;
            
            const tempInput = document.createElement('textarea');
            tempInput.value = shareUrl;
            document.body.appendChild(tempInput);
            tempInput.select();
            
            try {
                document.execCommand('copy'); 
                showSystemMessage(`${linkText} copied to clipboard!`, 'bg-blue-100 text-blue-800');
            } catch (err) {
                console.error('Could not copy text: ', err);
                showSystemMessage("Error copying link. Check console.", 'bg-red-100 text-red-800');
            }
            
            document.body.removeChild(tempInput);
        };

        /**
         * Checks the URL for fullview or share parameters and acts accordingly.
         */
        async function handleUrlParameters() {
            if (!isAuthReady) {
                // Should only be called after auth is ready
                return; 
            }
            
            const urlParams = new URLSearchParams(window.location.search);
            const fullViewId = urlParams.get('fullview');
            const shareId = urlParams.get('share');

            if (fullViewId) {
                // Full view takes precedence - loads content without UI
                await renderFullView(fullViewId);
                return; // Stop further processing
            }
            
            // If not in full view, check for a share link.
            if (shareId) {
                try {
                    const item = await getMediaMetadata(shareId);
                    window.showMediaModal(item);
                } catch (error) {
                    console.error("Share Link Error:", error);
                    showSystemMessage(`Could not load shared file ID: ${shareId}. Error: ${error.message}`, 'bg-red-100 text-red-800');
                } finally {
                    // Clear the share parameter after processing to keep the main view clean
                    history.replaceState(null, '', window.location.pathname);
                }
            }
        }


        /**
         * Shows a system message in the designated box.
         */
        function showSystemMessage(message, classes) {
            messageBox.textContent = message;
            messageBox.className = `p-3 mb-4 text-sm rounded-lg ${classes}`;
            messageBox.classList.remove('hidden');
            setTimeout(() => messageBox.classList.add('hidden'), 5000);
        }

        /**
         * Controls the loading state of the upload button.
         */
        function setLoading(isLoading, text = "Upload File") {
            uploadBtn.disabled = isLoading;
            uploadSpinner.classList.toggle('hidden', !isLoading);
            document.getElementById('upload-text').textContent = text;
        }

        /**
         * Opens the modal and loads the full media content, handling all preview types.
         */
        window.showMediaModal = async (item) => {
            modalContent.innerHTML = `<div class="text-center p-8">
                                        <p class="text-xl font-semibold mb-4 text-gray-700">Loading ${item.title}...</p>
                                        <div class="animate-spin h-8 w-8 border-4 border-indigo-500 border-t-transparent rounded-full mx-auto"></div>
                                        <p class="mt-2 text-sm text-gray-500">Retrieving ${item.chunkCount} chunks...</p>
                                      </div>`;
            modal.classList.remove('hidden');

            try {
                const dataUrl = await getAndReassembleMedia(item.id, item.mimeTypeHeader, item.chunkCount);
                
                let mediaElement;
                const mimeType = item.mimeType;
                
                // Determine if a browser preview is possible
                const isPreviewable = mimeType.startsWith('image/') || 
                                      mimeType.startsWith('video/') || 
                                      mimeType.startsWith('audio/') || 
                                      mimeType.startsWith('text/') || 
                                      mimeType === 'application/pdf' ||
                                      mimeType === 'application/json' || 
                                      mimeType === 'application/xml';
                
                let warningIcon = '';

                if (mimeType.startsWith('image/')) {
                    mediaElement = `<img src="${dataUrl}" alt="${item.title}" class="max-h-[80vh] w-full object-contain mx-auto rounded-lg shadow-lg">`;
                } else if (mimeType.startsWith('video/')) {
                    mediaElement = `<video src="${dataUrl}" controls autoplay loop class="max-h-[80vh] w-full mx-auto rounded-lg shadow-lg"></video>`;
                } else if (mimeType.startsWith('audio/')) { 
                    mediaElement = `<div class="p-8 bg-gray-100 rounded-lg"><audio src="${dataUrl}" controls autoplay class="w-full max-w-lg mx-auto block"></audio></div>`;
                } else if (mimeType === 'application/pdf') { 
                    mediaElement = `<iframe src="${dataUrl}" class="w-full h-[80vh] border-0 rounded-lg shadow-lg"></iframe>`;
                } else if (mimeType.startsWith('text/') || mimeType === 'application/json' || mimeType === 'application/xml') {
                    // Display text/code content
                    const base64Data = dataUrl.substring(dataUrl.indexOf(',') + 1);
                    const decodedText = atob(base64Data);
                    // Minimal syntax highlighting based on file type
                    const languageClass = mimeType.split('/').pop() || 'plaintext'; 
                    mediaElement = `<pre class="bg-gray-100 p-4 rounded-lg overflow-x-auto text-sm max-h-[70vh]"><code class="language-${languageClass}">${decodedText}</code></pre>`;
                } else {
                     // Non-previewable types (Zip, executable, etc.)
                     warningIcon = `
                        <div class="p-3 bg-yellow-100 text-yellow-800 rounded-lg flex items-center mb-4">
                            <!-- Warning Icon SVG -->
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-3 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                            </svg>
                            <span class="font-semibold">File Type Warning:</span> This file type (${mimeType}) cannot be previewed.
                        </div>`;
                     
                     // Provide a download link
                     const fileName = `${item.title.replace(/\s/g, '_')}_${item.id.substring(0, 4)}.${mimeType.split('/').pop() || 'file'}`;
                     mediaElement = `<div class="p-8 text-center">
                                         <p class="text-xl font-bold mb-2 text-gray-800">No Direct Preview Available</p>
                                         <p class="mb-4 text-gray-600">The browser cannot render this file type.</p>
                                         <a href="${dataUrl}" download="${fileName}" 
                                            class="inline-block px-6 py-3 bg-green-600 text-white font-bold rounded-xl hover:bg-green-700 transition duration-150">
                                            Download File (${(item.fileSize / (1024 * 1024)).toFixed(2)} MB)
                                         </a>
                                      </div>`;
                }

                modalContent.innerHTML = `
                    <h3 class="text-2xl font-bold mb-4 text-gray-800">${item.title}</h3>
                    ${warningIcon}
                    <div class="border-t pt-4">
                        ${mediaElement}
                    </div>
                `;

            } catch (error) {
                console.error("Modal Loading Error:", error);
                modalContent.innerHTML = `<div class="p-8 text-center text-red-600">
                                            <h3 class="text-xl font-bold mb-2">Error Loading Media</h3>
                                            <p>${error.message}</p>
                                            <p class="mt-4 text-sm text-gray-500">File reassembly failed. Data may be incomplete or corrupted.</p>
                                          </div>`;
            }
        }
        
        /**
         * Deletes a media item and all its chunks.
         */
        window.deleteMedia = async (mediaId, title, chunkCount) => {
            // Using the modal as a confirmation dialog
            modalContent.innerHTML = `
                <div class="p-6 text-center">
                    <h3 class="text-xl font-bold mb-4 text-gray-800">Confirm Deletion</h3>
                    <p class="mb-6">Are you sure you want to delete "${title}"? This action is irreversible and will delete ${chunkCount} chunks.</p>
                    <div class="flex justify-center space-x-4">
                        <button id="cancel-delete" class="px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400">Cancel</button>
                        <button id="confirm-delete" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Delete Permanently</button>
                    </div>
                </div>
            `;
            modal.classList.remove('hidden');

            document.getElementById('cancel-delete').onclick = () => modal.classList.add('hidden');
            
            document.getElementById('confirm-delete').onclick = async () => {
                modal.classList.add('hidden');
                showSystemMessage(`Deleting ${title}...`, 'bg-indigo-100 text-indigo-800');

                try {
                    const mediaDocRef = doc(db, MEDIA_COLLECTION_PATH, mediaId);
                    
                    // 1. Delete all chunks in the subcollection
                    const chunkCollectionRef = collection(db, MEDIA_COLLECTION_PATH, mediaId, 'chunks');
                    const chunkSnapshot = await getDocs(query(chunkCollectionRef));

                    const deletePromises = [];
                    chunkSnapshot.forEach(chunkDoc => {
                        deletePromises.push(deleteDoc(chunkDoc.ref));
                    });

                    await Promise.all(deletePromises);

                    // 2. Delete the main metadata document
                    await deleteDoc(mediaDocRef);

                    showSystemMessage(`Successfully deleted "${title}".`, 'bg-green-100 text-green-800');

                } catch (error) {
                    console.error("Deletion Error:", error);
                    showSystemMessage(`Deletion failed: ${error.message}`, 'bg-red-100 text-red-800');
                }
            };
        };

        // Attach event listeners
        mediaFileInput.addEventListener('change', () => {
            uploadBtn.disabled = !mediaFileInput.files.length || !isAuthReady;
            if (mediaFileInput.files.length) {
                uploadStatus.textContent = "File selected. Ready to upload.";
            } else {
                 uploadStatus.textContent = "Ready to upload.";
            }
        });

        uploadBtn.addEventListener('click', handleUpload);
        
        // Start the application after the window loads
        window.onload = initFirebase;
    </script>
</body>
</html>

