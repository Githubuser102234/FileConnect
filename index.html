<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Base64 Chunked Media Sharing</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for aesthetic appeal and responsiveness */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            min-height: 100vh;
        }
        .media-container {
            position: relative;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            overflow: hidden;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            background-color: #1f2937; /* Dark background for media */
        }
        .media-item {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }
        .media-container:hover .media-item {
            transform: scale(1.03);
        }
        /* Custom scrollbar for better look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        ::-webkit-scrollbar-thumb {
            background: #a1a1aa;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #71717a;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <!-- Main Application Container -->
    <div id="app" class="max-w-7xl mx-auto">
        
        <!-- Header -->
        <header class="text-center mb-10 py-4 bg-white rounded-xl shadow-lg">
            <h1 class="text-4xl font-extrabold text-indigo-700">Media Vault (Chunked Firestore)</h1>
            <p id="user-info" class="text-sm mt-2 text-gray-500">Initializing Firebase and signing in anonymously...</p>
        </header>

        <!-- Upload Section -->
        <section id="upload-section" class="bg-white p-6 rounded-xl shadow-lg mb-10">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">Upload New Media (Max ~15MB)</h2>
            
            <div id="message-box" class="hidden p-3 mb-4 text-sm rounded-lg" role="alert"></div>

            <input type="file" id="media-file-input" accept="image/*,video/*" class="w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-full file:border-0
                file:text-sm file:font-semibold
                file:bg-indigo-50 file:text-indigo-700
                hover:file:bg-indigo-100" />
            
            <div class="mt-4">
                <input type="text" id="media-title-input" placeholder="Title (e.g., Sunset View)"
                       class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
            </div>

            <button id="upload-btn" class="mt-4 w-full px-6 py-3 bg-indigo-600 text-white font-bold rounded-xl hover:bg-indigo-700 transition duration-150 shadow-md disabled:opacity-50" disabled>
                <span id="upload-text">Upload File</span>
                <span id="upload-spinner" class="hidden animate-spin h-5 w-5 border-4 border-white border-t-transparent rounded-full ml-2"></span>
            </button>
            <p class="text-xs text-red-500 mt-2">Warning: Large files might take significant time to process and upload.</p>
        </section>

        <!-- Gallery Section -->
        <section id="gallery-section">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">Shared Media Gallery</h2>
            <div id="media-gallery" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                <div id="loading-gallery" class="col-span-full text-center text-gray-500 p-10">
                    Loading media...
                </div>
                <!-- Media items will be injected here -->
            </div>
        </section>

        <!-- Modal for displaying full media or error messages -->
        <div id="media-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center p-4 z-50 transition-opacity duration-300">
            <div class="bg-white rounded-xl max-w-4xl w-full p-4 relative">
                <button onclick="document.getElementById('media-modal').classList.add('hidden')" class="absolute top-2 right-2 text-gray-700 hover:text-gray-900 text-3xl font-bold p-1 leading-none rounded-full bg-gray-200 w-10 h-10 flex items-center justify-center">
                    &times;
                </button>
                <div id="modal-content">
                    <!-- Media element or error message will be placed here -->
                </div>
            </div>
        </div>

    </div>

    <!-- Firebase and Application Logic -->
    <script type="module">
        // 1. HARDCODED CONFIGURATION AND IMPORTS (Based on User Request)
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyBxNgcLIk4KLxzqVsgA7tLHHM7Rpf1PWvY",
            authDomain: "fileconnect-fd3e3.firebaseapp.com",
            projectId: "fileconnect-fd3e3",
            storageBucket: "fileconnect-fd3e3.firebasestorage.app",
            messagingSenderId: "900879046037",
            appId: "1:900879046037:web:8560c5b3b57be8740d929c",
            measurementId: "G-B7RR873MSB"
        };
        const FIXED_APP_ID = FIREBASE_CONFIG.projectId; // Using projectId as a fixed ID for the Firestore path

        // Load specific SDK versions provided by the user
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";
        import { getFirestore, doc, addDoc, setDoc, onSnapshot, collection, query, orderBy, serverTimestamp, getDocs, deleteDoc, runTransaction, setLogLevel } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-analytics.js"; // Included per user request

        // Global Firebase instances
        let app, db, auth;
        let userId = null;
        let isAuthReady = false;

        // CONSTANTS
        // Firestore limit is 1MB (~1,048,576 bytes). We aim for chunks under 900KB of base64 string.
        const CHUNK_SIZE = 900000; // 900KB of base64 string characters

        const messageBox = document.getElementById('message-box');
        const uploadBtn = document.getElementById('upload-btn');
        const uploadText = document.getElementById('upload-text');
        const uploadSpinner = document.getElementById('upload-spinner');
        const mediaFileInput = document.getElementById('media-file-input');
        const mediaTitleInput = document.getElementById('media-title-input');
        const mediaGallery = document.getElementById('media-gallery');
        const modal = document.getElementById('media-modal');
        const modalContent = document.getElementById('modal-content');

        /**
         * Initializes Firebase and authenticates the user anonymously.
         */
        async function initFirebase() {
            try {
                // setLogLevel('Debug'); // Uncomment for detailed debug logs
                app = initializeApp(FIREBASE_CONFIG);
                getAnalytics(app); // Initialize analytics as requested
                db = getFirestore(app);
                auth = getAuth(app);

                // Start anonymous sign-in process
                await signInAnonymously(auth);

                // Authentication listener to get user ID
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('user-info').textContent = `User ID: ${userId} (Signed in anonymously)`;
                        isAuthReady = true;
                        uploadBtn.disabled = false;
                        startGalleryListener(); // Start listening for media after auth
                    } else {
                        document.getElementById('user-info').textContent = `Authentication failed. Cannot proceed.`;
                        uploadBtn.disabled = true;
                    }
                });

            } catch (error) {
                console.error("Firebase Initialization/Authentication Error:", error);
                showSystemMessage(`Authentication failed: ${error.message}`, 'bg-red-100 text-red-800');
            }
        }

        /**
         * Converts a File object to a Base64 data URL string.
         * @param {File} file The file to convert.
         * @returns {Promise<string>} A promise that resolves with the Base64 data URL.
         */
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = (error) => reject(error);
            });
        }

        /**
         * Splits a Base64 string into chunks of a specified size.
         * Skips the MIME type prefix (e.g., 'data:image/jpeg;base64,').
         * @param {string} base64DataUrl The full Base64 data URL string.
         * @returns {Array<string>} An array of Base64 data chunks.
         */
        function chunkBase64(base64DataUrl) {
            // Find the start of the actual base64 data after the header
            const commaIndex = base64DataUrl.indexOf(',');
            if (commaIndex === -1) {
                throw new Error("Invalid Base64 Data URL format.");
            }
            const base64String = base64DataUrl.substring(commaIndex + 1);
            
            const chunks = [];
            for (let i = 0; i < base64String.length; i += CHUNK_SIZE) {
                chunks.push(base64String.substring(i, i + CHUNK_SIZE));
            }
            return chunks;
        }

        /**
         * Uploads the media file in chunks to Firestore.
         */
        async function handleUpload() {
            const file = mediaFileInput.files[0];
            const title = mediaTitleInput.value.trim();

            if (!file || !title) {
                showSystemMessage("Please select a file and enter a title.", 'bg-yellow-100 text-yellow-800');
                return;
            }

            setLoading(true, "Encoding & Chunking...");

            let base64DataUrl, chunks;
            try {
                base64DataUrl = await fileToBase64(file);
                chunks = chunkBase64(base64DataUrl);
            } catch (error) {
                setLoading(false);
                showSystemMessage(`File processing failed: ${error.message}`, 'bg-red-100 text-red-800');
                return;
            }

            if (chunks.length > 20) {
                 setLoading(false);
                 showSystemMessage(`File is too large (${chunks.length} chunks). Max recommended is 20 chunks (approx 15MB).`, 'bg-red-100 text-red-800');
                 return;
            }

            setLoading(true, `Uploading ${chunks.length} chunks...`);

            try {
                // Public Collection Path: artifacts/{projectId}/public/data/media_files
                const mediaCollectionPath = `artifacts/${FIXED_APP_ID}/public/data/media_files`;
                
                // 1. Create the root document for metadata
                const newDocRef = await addDoc(collection(db, mediaCollectionPath), {
                    title: title,
                    mimeType: file.type,
                    chunkCount: chunks.length,
                    fileSize: file.size, // Original file size in bytes
                    uploadedBy: userId,
                    timestamp: serverTimestamp()
                });

                // 2. Upload the chunks to a subcollection
                const chunkCollectionRef = collection(db, mediaCollectionPath, newDocRef.id, 'chunks');
                
                // Get the MIME type header to store with the metadata
                const mimeTypeHeader = base64DataUrl.substring(0, base64DataUrl.indexOf(',') + 1);

                // Use a transaction to ensure both the main doc update and chunk uploads are atomic
                // Note: Transactions are best for operations on a few documents. For many, sequential set/batch writes are alternatives.
                // Given the chunk count is limited, we use setDoc sequentially for simplicity and error visibility.
                
                // Update the main document with the mimeTypeHeader outside the transaction for simplicity
                await setDoc(newDocRef, { mimeTypeHeader: mimeTypeHeader }, { merge: true });

                const chunkUploadPromises = [];
                for (let i = 0; i < chunks.length; i++) {
                    const chunkDocRef = doc(chunkCollectionRef, i.toString());
                    chunkUploadPromises.push(
                        setDoc(chunkDocRef, {
                            index: i,
                            data: chunks[i],
                            timestamp: serverTimestamp()
                        })
                    );
                }
                
                // Wait for all chunks to upload
                await Promise.all(chunkUploadPromises);

                showSystemMessage(`Successfully uploaded "${title}" in ${chunks.length} chunks!`, 'bg-green-100 text-green-800');
                // Clear inputs
                mediaFileInput.value = '';
                mediaTitleInput.value = '';

            } catch (error) {
                console.error("Firestore Upload Error:", error);
                showSystemMessage(`Upload failed: ${error.message}`, 'bg-red-100 text-red-800');
            } finally {
                setLoading(false);
            }
        }

        /**
         * Retrieves all chunks for a given media ID and reassembles the Base64 data URL.
         * @param {string} mediaId The ID of the media document.
         * @returns {Promise<string>} The complete Base64 data URL.
         */
        async function getAndReassembleMedia(mediaId, mimeTypeHeader, chunkCount) {
            const mediaCollectionPath = `artifacts/${FIXED_APP_ID}/public/data/media_files`;
            const chunkCollectionRef = collection(db, mediaCollectionPath, mediaId, 'chunks');
            
            // Fetch all chunk documents, ordered by index
            const chunkQuery = query(chunkCollectionRef, orderBy('index', 'asc'));
            const chunkQuerySnapshot = await getDocs(chunkQuery);

            if (chunkQuerySnapshot.docs.length !== chunkCount) {
                 throw new Error("Mismatched chunk count. Data might be corrupted or incomplete.");
            }

            const chunkArray = Array(chunkCount);

            chunkQuerySnapshot.forEach(docSnapshot => {
                const chunkData = docSnapshot.data();
                if (typeof chunkData.index === 'number' && chunkData.data) {
                    chunkArray[chunkData.index] = chunkData.data;
                }
            });

            // Reassemble the full Base64 string
            const fullBase64String = chunkArray.join('');
            
            if (!fullBase64String) {
                throw new Error("Reassembled Base64 string is empty.");
            }

            // Prepend the MIME type header to form the complete data URL
            return `${mimeTypeHeader}${fullBase64String}`;
        }


        /**
         * Starts the real-time listener for the media gallery.
         */
        function startGalleryListener() {
            if (!isAuthReady || !db) return;

            const mediaCollectionPath = `artifacts/${FIXED_APP_ID}/public/data/media_files`;
            const mediaQuery = query(collection(db, mediaCollectionPath), orderBy('timestamp', 'desc'));

            onSnapshot(mediaQuery, (snapshot) => {
                const mediaItems = [];
                snapshot.forEach(doc => {
                    // Check for necessary fields before display
                    const data = doc.data();
                    if (data.title && data.mimeType && data.chunkCount !== undefined && data.mimeTypeHeader) {
                         mediaItems.push({ id: doc.id, ...data });
                    }
                });
                renderGallery(mediaItems);
            }, (error) => {
                console.error("Gallery Snapshot Error:", error);
                document.getElementById('loading-gallery').textContent = `Failed to load gallery: ${error.message}`;
            });
        }

        /**
         * Renders the media gallery based on the fetched metadata.
         * @param {Array<Object>} items Array of media metadata objects.
         */
        function renderGallery(items) {
            mediaGallery.innerHTML = ''; // Clear existing content

            if (items.length === 0) {
                mediaGallery.innerHTML = `<p class="col-span-full text-center text-gray-500 p-10">No media uploaded yet. Be the first!</p>`;
                return;
            }

            items.forEach(item => {
                const isVideo = item.mimeType.startsWith('video/');
                
                // Create the card element
                const card = document.createElement('div');
                card.className = 'bg-white rounded-xl shadow-md overflow-hidden transition transform hover:shadow-xl hover:-translate-y-1 cursor-pointer';
                card.onclick = () => showMediaModal(item);

                // Determine the preview element (placeholder image for now)
                let previewHtml;
                const mediaType = item.mimeType.startsWith('video') ? 'VIDEO' : 'IMAGE';
                const placeholderText = `${mediaType} (${(item.fileSize / (1024 * 1024)).toFixed(2)} MB)`;

                previewHtml = `<div class="media-container"><img src="https://placehold.co/600x337/3B82F6/ffffff?text=${encodeURIComponent(placeholderText)}%0A(Click%20to%20Load)" class="media-item object-cover w-full h-full" alt="Media Preview"/></div>`;

                card.innerHTML = `
                    ${previewHtml}
                    <div class="p-4">
                        <h3 class="text-lg font-semibold text-gray-800 truncate">${item.title}</h3>
                        <p class="text-sm text-gray-500 mt-1">
                            ${mediaType} | 
                            ${item.chunkCount} chunks
                        </p>
                        <p class="text-xs text-gray-400 mt-1">Uploaded by: ${item.uploadedBy.substring(0, 8)}...</p>
                        <button onclick="event.stopPropagation(); deleteMedia('${item.id}', '${item.title}', ${item.chunkCount})" 
                                class="mt-2 text-xs text-red-500 hover:text-red-700 transition duration-150">
                            Delete
                        </button>
                    </div>
                `;
                mediaGallery.appendChild(card);
            });
        }

        /**
         * Shows a system message in the designated box.
         * @param {string} message The message content.
         * @param {string} classes Tailwind classes for styling (e.g., 'bg-green-100 text-green-800').
         */
        function showSystemMessage(message, classes) {
            messageBox.textContent = message;
            messageBox.className = `p-3 mb-4 text-sm rounded-lg ${classes}`;
            messageBox.classList.remove('hidden');
            setTimeout(() => messageBox.classList.add('hidden'), 5000);
        }

        /**
         * Controls the loading state of the upload button.
         * @param {boolean} isLoading Whether the application is loading.
         * @param {string} text Optional custom text for the button.
         */
        function setLoading(isLoading, text = "Upload File") {
            uploadBtn.disabled = isLoading;
            uploadText.textContent = text;
            if (isLoading) {
                uploadSpinner.classList.remove('hidden');
            } else {
                uploadSpinner.classList.add('hidden');
                uploadText.textContent = "Upload File";
            }
        }

        /**
         * Opens the modal and loads the full media content.
         * @param {Object} item The media metadata object.
         */
        async function showMediaModal(item) {
            modalContent.innerHTML = `<div class="text-center p-8">
                                        <p class="text-xl font-semibold mb-4 text-gray-700">Loading ${item.title}...</p>
                                        <div class="animate-spin h-8 w-8 border-4 border-indigo-500 border-t-transparent rounded-full mx-auto"></div>
                                        <p class="mt-2 text-sm text-gray-500">Retrieving ${item.chunkCount} chunks...</p>
                                      </div>`;
            modal.classList.remove('hidden');

            try {
                const dataUrl = await getAndReassembleMedia(item.id, item.mimeTypeHeader, item.chunkCount);
                
                let mediaElement;
                if (item.mimeType.startsWith('image/')) {
                    mediaElement = `<img src="${dataUrl}" alt="${item.title}" class="max-h-[80vh] w-full object-contain mx-auto rounded-lg shadow-lg">`;
                } else if (item.mimeType.startsWith('video/')) {
                    mediaElement = `<video src="${dataUrl}" controls autoplay loop class="max-h-[80vh] w-full mx-auto rounded-lg shadow-lg"></video>`;
                } else {
                    mediaElement = `<p class="text-red-500">Unsupported media type: ${item.mimeType}</p>`;
                }

                modalContent.innerHTML = `
                    <h3 class="text-2xl font-bold mb-4 text-gray-800">${item.title}</h3>
                    <div class="border-t pt-4">
                        ${mediaElement}
                    </div>
                `;

            } catch (error) {
                console.error("Modal Loading Error:", error);
                modalContent.innerHTML = `<div class="p-8 text-center text-red-600">
                                            <h3 class="text-xl font-bold mb-2">Error Loading Media</h3>
                                            <p>${error.message}</p>
                                            <p class="mt-4 text-sm text-gray-500">Check the console for details. Data may be incomplete or corrupted.</p>
                                          </div>`;
            }
        }
        
        /**
         * Deletes a media item and all its chunks.
         */
        window.deleteMedia = async (mediaId, title, chunkCount) => {
            // Using the modal as a confirmation dialog instead of window.confirm()
            modalContent.innerHTML = `
                <div class="p-6 text-center">
                    <h3 class="text-xl font-bold mb-4 text-gray-800">Confirm Deletion</h3>
                    <p class="mb-6">Are you sure you want to delete "${title}"? This action is irreversible and will delete ${chunkCount} chunks.</p>
                    <div class="flex justify-center space-x-4">
                        <button id="cancel-delete" class="px-4 py-2 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400">Cancel</button>
                        <button id="confirm-delete" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Delete Permanently</button>
                    </div>
                </div>
            `;
            modal.classList.remove('hidden');

            document.getElementById('cancel-delete').onclick = () => modal.classList.add('hidden');
            
            document.getElementById('confirm-delete').onclick = async () => {
                modal.classList.add('hidden'); // Hide modal immediately
                showSystemMessage(`Deleting ${title}...`, 'bg-indigo-100 text-indigo-800');

                try {
                    const mediaCollectionPath = `artifacts/${FIXED_APP_ID}/public/data/media_files`;
                    const mediaDocRef = doc(db, mediaCollectionPath, mediaId);
                    
                    // 1. Delete all chunks in the subcollection
                    const chunkCollectionRef = collection(db, mediaCollectionPath, mediaId, 'chunks');
                    const chunkSnapshot = await getDocs(query(chunkCollectionRef));

                    const deletePromises = [];
                    chunkSnapshot.forEach(chunkDoc => {
                        deletePromises.push(deleteDoc(chunkDoc.ref));
                    });

                    await Promise.all(deletePromises);

                    // 2. Delete the main metadata document
                    await deleteDoc(mediaDocRef);

                    showSystemMessage(`Successfully deleted "${title}" and all associated chunks.`, 'bg-green-100 text-green-800');

                } catch (error) {
                    console.error("Deletion Error:", error);
                    showSystemMessage(`Deletion failed: ${error.message}`, 'bg-red-100 text-red-800');
                }
            };
        };

        // Attach event listeners
        mediaFileInput.addEventListener('change', () => {
            uploadBtn.disabled = !mediaFileInput.files.length || !isAuthReady;
        });

        uploadBtn.addEventListener('click', handleUpload);

        // Export window function for modal display
        window.showMediaModal = showMediaModal;
        
        // Start the application
        window.onload = initFirebase;
    </script>
</body>
</html>

